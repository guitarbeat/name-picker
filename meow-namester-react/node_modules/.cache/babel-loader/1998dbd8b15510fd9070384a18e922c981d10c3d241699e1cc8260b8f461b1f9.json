{"ast":null,"code":"/**\n * @module PreferenceSorter\n * @description A class that implements a merge sort algorithm with custom comparisons\n * for sorting cat names based on user preferences.\n */\n\nexport class PreferenceSorter {\n  constructor(items) {\n    this.items = items;\n    this.preferences = new Map();\n    this.currentRankings = [...items];\n    this.ranks = [];\n    this.rec = new Array(items.length).fill(0);\n  }\n\n  // When comparing items, we'll use the name property for the map key\n  addPreference(item1, item2, value) {\n    const key = `${item1.name}-${item2.name}`;\n    this.preferences.set(key, value);\n  }\n  getPreference(item1, item2) {\n    const key = `${item1.name}-${item2.name}`;\n    const reverseKey = `${item2.name}-${item1.name}`;\n    if (this.preferences.has(key)) {\n      return this.preferences.get(key);\n    }\n    if (this.preferences.has(reverseKey)) {\n      return -this.preferences.get(reverseKey);\n    }\n    return 0;\n  }\n  getCurrentRankings() {\n    if (this.ranks.length > 0) {\n      return this.ranks;\n    }\n    return this.currentRankings;\n  }\n  async sort(compareCallback) {\n    console.log('Starting sort process with items:', this.items);\n    const n = this.items.length;\n    if (!this.rec || this.rec.length !== n) {\n      this.rec = new Array(n).fill(0);\n    }\n    await this.sortRecursive(0, n - 1, compareCallback);\n    console.log('Sort completed. Final ranks:', this.ranks);\n    return this.ranks;\n  }\n  async sortRecursive(left, right, compareCallback) {\n    if (right - left < 1) {\n      if (left === right) {\n        this.ranks.push(this.items[left]);\n        console.log(`Added single item to ranks: ${this.items[left].name}`);\n      }\n      return;\n    }\n    const mid = Math.floor((left + right) / 2);\n    console.log(`Splitting array at indices ${left}-${mid} and ${mid + 1}-${right}`);\n    await this.sortRecursive(left, mid, compareCallback);\n    await this.sortRecursive(mid + 1, right, compareCallback);\n    await this.mergeSubGroups(left, mid, right, compareCallback);\n  }\n  async mergeSubGroups(left, mid, right, compareCallback) {\n    console.log(`Merging subarrays: ${left}-${mid} with ${mid + 1}-${right}`);\n    let i = left;\n    let j = mid + 1;\n    const merged = [];\n    while (i <= mid && j <= right) {\n      console.log(`Comparing ${this.items[i].name} with ${this.items[j].name}`);\n      const result = await compareCallback(this.items[i], this.items[j]);\n      console.log(`Comparison result: ${result}`);\n      if (result <= -0.5) {\n        // First name preferred\n        console.log(`${this.items[i].name} preferred over ${this.items[j].name}`);\n        merged.push(this.items[i++]);\n      } else if (result >= 0.5) {\n        // Second name preferred\n        console.log(`${this.items[j].name} preferred over ${this.items[i].name}`);\n        merged.push(this.items[j++]);\n      } else {\n        // Handle near-ties with slight preference\n        console.log(`Near tie between ${this.items[i].name} and ${this.items[j].name}`);\n        if (result < 0) {\n          merged.push(this.items[i++]);\n          merged.push(this.items[j++]);\n        } else {\n          merged.push(this.items[j++]);\n          merged.push(this.items[i++]);\n        }\n      }\n    }\n\n    // Add remaining elements\n    while (i <= mid) {\n      console.log(`Adding remaining left item: ${this.items[i].name}`);\n      merged.push(this.items[i++]);\n    }\n    while (j <= right) {\n      console.log(`Adding remaining right item: ${this.items[j].name}`);\n      merged.push(this.items[j++]);\n    }\n\n    // Update original array\n    for (let k = 0; k < merged.length; k++) {\n      this.items[left + k] = merged[k];\n      this.currentRankings[left + k] = merged[k];\n    }\n\n    // Only update ranks at the final merge\n    if (left === 0 && right === this.items.length - 1) {\n      this.ranks = [...merged];\n    }\n    console.log(`Merged result: ${merged.map(item => item.name).join(', ')}`);\n  }\n}","map":{"version":3,"names":["PreferenceSorter","constructor","items","preferences","Map","currentRankings","ranks","rec","Array","length","fill","addPreference","item1","item2","value","key","name","set","getPreference","reverseKey","has","get","getCurrentRankings","sort","compareCallback","console","log","n","sortRecursive","left","right","push","mid","Math","floor","mergeSubGroups","i","j","merged","result","k","map","item","join"],"sources":["/Users/aaron/Desktop/Side Projects/name-picker/meow-namester-react/src/utils/sortingAlgorithm.js"],"sourcesContent":["/**\n * @module PreferenceSorter\n * @description A class that implements a merge sort algorithm with custom comparisons\n * for sorting cat names based on user preferences.\n */\n\nexport class PreferenceSorter {\n    constructor(items) {\n        this.items = items;\n        this.preferences = new Map();\n        this.currentRankings = [...items];\n        this.ranks = [];\n        this.rec = new Array(items.length).fill(0);\n    }\n\n    // When comparing items, we'll use the name property for the map key\n    addPreference(item1, item2, value) {\n        const key = `${item1.name}-${item2.name}`;\n        this.preferences.set(key, value);\n    }\n\n    getPreference(item1, item2) {\n        const key = `${item1.name}-${item2.name}`;\n        const reverseKey = `${item2.name}-${item1.name}`;\n        \n        if (this.preferences.has(key)) {\n            return this.preferences.get(key);\n        }\n        if (this.preferences.has(reverseKey)) {\n            return -this.preferences.get(reverseKey);\n        }\n        return 0;\n    }\n\n    getCurrentRankings() {\n        if (this.ranks.length > 0) {\n            return this.ranks;\n        }\n        return this.currentRankings;\n    }\n\n    async sort(compareCallback) {\n        console.log('Starting sort process with items:', this.items);\n        const n = this.items.length;\n        \n        if (!this.rec || this.rec.length !== n) {\n            this.rec = new Array(n).fill(0);\n        }\n        \n        await this.sortRecursive(0, n - 1, compareCallback);\n        console.log('Sort completed. Final ranks:', this.ranks);\n        return this.ranks;\n    }\n\n    async sortRecursive(left, right, compareCallback) {\n        if (right - left < 1) {\n            if (left === right) {\n                this.ranks.push(this.items[left]);\n                console.log(`Added single item to ranks: ${this.items[left].name}`);\n            }\n            return;\n        }\n\n        const mid = Math.floor((left + right) / 2);\n        console.log(`Splitting array at indices ${left}-${mid} and ${mid + 1}-${right}`);\n        await this.sortRecursive(left, mid, compareCallback);\n        await this.sortRecursive(mid + 1, right, compareCallback);\n        await this.mergeSubGroups(left, mid, right, compareCallback);\n    }\n\n    async mergeSubGroups(left, mid, right, compareCallback) {\n        console.log(`Merging subarrays: ${left}-${mid} with ${mid + 1}-${right}`);\n        let i = left;\n        let j = mid + 1;\n        const merged = [];\n\n        while (i <= mid && j <= right) {\n            console.log(`Comparing ${this.items[i].name} with ${this.items[j].name}`);\n            const result = await compareCallback(this.items[i], this.items[j]);\n            console.log(`Comparison result: ${result}`);\n\n            if (result <= -0.5) {  // First name preferred\n                console.log(`${this.items[i].name} preferred over ${this.items[j].name}`);\n                merged.push(this.items[i++]);\n            } else if (result >= 0.5) {  // Second name preferred\n                console.log(`${this.items[j].name} preferred over ${this.items[i].name}`);\n                merged.push(this.items[j++]);\n            } else {\n                // Handle near-ties with slight preference\n                console.log(`Near tie between ${this.items[i].name} and ${this.items[j].name}`);\n                if (result < 0) {\n                    merged.push(this.items[i++]);\n                    merged.push(this.items[j++]);\n                } else {\n                    merged.push(this.items[j++]);\n                    merged.push(this.items[i++]);\n                }\n            }\n        }\n\n        // Add remaining elements\n        while (i <= mid) {\n            console.log(`Adding remaining left item: ${this.items[i].name}`);\n            merged.push(this.items[i++]);\n        }\n        while (j <= right) {\n            console.log(`Adding remaining right item: ${this.items[j].name}`);\n            merged.push(this.items[j++]);\n        }\n\n        // Update original array\n        for (let k = 0; k < merged.length; k++) {\n            this.items[left + k] = merged[k];\n            this.currentRankings[left + k] = merged[k];\n        }\n\n        // Only update ranks at the final merge\n        if (left === 0 && right === this.items.length - 1) {\n            this.ranks = [...merged];\n        }\n\n        console.log(`Merged result: ${merged.map(item => item.name).join(', ')}`);\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMA,gBAAgB,CAAC;EAC1BC,WAAWA,CAACC,KAAK,EAAE;IACf,IAAI,CAACA,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,WAAW,GAAG,IAAIC,GAAG,CAAC,CAAC;IAC5B,IAAI,CAACC,eAAe,GAAG,CAAC,GAAGH,KAAK,CAAC;IACjC,IAAI,CAACI,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,GAAG,GAAG,IAAIC,KAAK,CAACN,KAAK,CAACO,MAAM,CAAC,CAACC,IAAI,CAAC,CAAC,CAAC;EAC9C;;EAEA;EACAC,aAAaA,CAACC,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAE;IAC/B,MAAMC,GAAG,GAAG,GAAGH,KAAK,CAACI,IAAI,IAAIH,KAAK,CAACG,IAAI,EAAE;IACzC,IAAI,CAACb,WAAW,CAACc,GAAG,CAACF,GAAG,EAAED,KAAK,CAAC;EACpC;EAEAI,aAAaA,CAACN,KAAK,EAAEC,KAAK,EAAE;IACxB,MAAME,GAAG,GAAG,GAAGH,KAAK,CAACI,IAAI,IAAIH,KAAK,CAACG,IAAI,EAAE;IACzC,MAAMG,UAAU,GAAG,GAAGN,KAAK,CAACG,IAAI,IAAIJ,KAAK,CAACI,IAAI,EAAE;IAEhD,IAAI,IAAI,CAACb,WAAW,CAACiB,GAAG,CAACL,GAAG,CAAC,EAAE;MAC3B,OAAO,IAAI,CAACZ,WAAW,CAACkB,GAAG,CAACN,GAAG,CAAC;IACpC;IACA,IAAI,IAAI,CAACZ,WAAW,CAACiB,GAAG,CAACD,UAAU,CAAC,EAAE;MAClC,OAAO,CAAC,IAAI,CAAChB,WAAW,CAACkB,GAAG,CAACF,UAAU,CAAC;IAC5C;IACA,OAAO,CAAC;EACZ;EAEAG,kBAAkBA,CAAA,EAAG;IACjB,IAAI,IAAI,CAAChB,KAAK,CAACG,MAAM,GAAG,CAAC,EAAE;MACvB,OAAO,IAAI,CAACH,KAAK;IACrB;IACA,OAAO,IAAI,CAACD,eAAe;EAC/B;EAEA,MAAMkB,IAAIA,CAACC,eAAe,EAAE;IACxBC,OAAO,CAACC,GAAG,CAAC,mCAAmC,EAAE,IAAI,CAACxB,KAAK,CAAC;IAC5D,MAAMyB,CAAC,GAAG,IAAI,CAACzB,KAAK,CAACO,MAAM;IAE3B,IAAI,CAAC,IAAI,CAACF,GAAG,IAAI,IAAI,CAACA,GAAG,CAACE,MAAM,KAAKkB,CAAC,EAAE;MACpC,IAAI,CAACpB,GAAG,GAAG,IAAIC,KAAK,CAACmB,CAAC,CAAC,CAACjB,IAAI,CAAC,CAAC,CAAC;IACnC;IAEA,MAAM,IAAI,CAACkB,aAAa,CAAC,CAAC,EAAED,CAAC,GAAG,CAAC,EAAEH,eAAe,CAAC;IACnDC,OAAO,CAACC,GAAG,CAAC,8BAA8B,EAAE,IAAI,CAACpB,KAAK,CAAC;IACvD,OAAO,IAAI,CAACA,KAAK;EACrB;EAEA,MAAMsB,aAAaA,CAACC,IAAI,EAAEC,KAAK,EAAEN,eAAe,EAAE;IAC9C,IAAIM,KAAK,GAAGD,IAAI,GAAG,CAAC,EAAE;MAClB,IAAIA,IAAI,KAAKC,KAAK,EAAE;QAChB,IAAI,CAACxB,KAAK,CAACyB,IAAI,CAAC,IAAI,CAAC7B,KAAK,CAAC2B,IAAI,CAAC,CAAC;QACjCJ,OAAO,CAACC,GAAG,CAAC,+BAA+B,IAAI,CAACxB,KAAK,CAAC2B,IAAI,CAAC,CAACb,IAAI,EAAE,CAAC;MACvE;MACA;IACJ;IAEA,MAAMgB,GAAG,GAAGC,IAAI,CAACC,KAAK,CAAC,CAACL,IAAI,GAAGC,KAAK,IAAI,CAAC,CAAC;IAC1CL,OAAO,CAACC,GAAG,CAAC,8BAA8BG,IAAI,IAAIG,GAAG,QAAQA,GAAG,GAAG,CAAC,IAAIF,KAAK,EAAE,CAAC;IAChF,MAAM,IAAI,CAACF,aAAa,CAACC,IAAI,EAAEG,GAAG,EAAER,eAAe,CAAC;IACpD,MAAM,IAAI,CAACI,aAAa,CAACI,GAAG,GAAG,CAAC,EAAEF,KAAK,EAAEN,eAAe,CAAC;IACzD,MAAM,IAAI,CAACW,cAAc,CAACN,IAAI,EAAEG,GAAG,EAAEF,KAAK,EAAEN,eAAe,CAAC;EAChE;EAEA,MAAMW,cAAcA,CAACN,IAAI,EAAEG,GAAG,EAAEF,KAAK,EAAEN,eAAe,EAAE;IACpDC,OAAO,CAACC,GAAG,CAAC,sBAAsBG,IAAI,IAAIG,GAAG,SAASA,GAAG,GAAG,CAAC,IAAIF,KAAK,EAAE,CAAC;IACzE,IAAIM,CAAC,GAAGP,IAAI;IACZ,IAAIQ,CAAC,GAAGL,GAAG,GAAG,CAAC;IACf,MAAMM,MAAM,GAAG,EAAE;IAEjB,OAAOF,CAAC,IAAIJ,GAAG,IAAIK,CAAC,IAAIP,KAAK,EAAE;MAC3BL,OAAO,CAACC,GAAG,CAAC,aAAa,IAAI,CAACxB,KAAK,CAACkC,CAAC,CAAC,CAACpB,IAAI,SAAS,IAAI,CAACd,KAAK,CAACmC,CAAC,CAAC,CAACrB,IAAI,EAAE,CAAC;MACzE,MAAMuB,MAAM,GAAG,MAAMf,eAAe,CAAC,IAAI,CAACtB,KAAK,CAACkC,CAAC,CAAC,EAAE,IAAI,CAAClC,KAAK,CAACmC,CAAC,CAAC,CAAC;MAClEZ,OAAO,CAACC,GAAG,CAAC,sBAAsBa,MAAM,EAAE,CAAC;MAE3C,IAAIA,MAAM,IAAI,CAAC,GAAG,EAAE;QAAG;QACnBd,OAAO,CAACC,GAAG,CAAC,GAAG,IAAI,CAACxB,KAAK,CAACkC,CAAC,CAAC,CAACpB,IAAI,mBAAmB,IAAI,CAACd,KAAK,CAACmC,CAAC,CAAC,CAACrB,IAAI,EAAE,CAAC;QACzEsB,MAAM,CAACP,IAAI,CAAC,IAAI,CAAC7B,KAAK,CAACkC,CAAC,EAAE,CAAC,CAAC;MAChC,CAAC,MAAM,IAAIG,MAAM,IAAI,GAAG,EAAE;QAAG;QACzBd,OAAO,CAACC,GAAG,CAAC,GAAG,IAAI,CAACxB,KAAK,CAACmC,CAAC,CAAC,CAACrB,IAAI,mBAAmB,IAAI,CAACd,KAAK,CAACkC,CAAC,CAAC,CAACpB,IAAI,EAAE,CAAC;QACzEsB,MAAM,CAACP,IAAI,CAAC,IAAI,CAAC7B,KAAK,CAACmC,CAAC,EAAE,CAAC,CAAC;MAChC,CAAC,MAAM;QACH;QACAZ,OAAO,CAACC,GAAG,CAAC,oBAAoB,IAAI,CAACxB,KAAK,CAACkC,CAAC,CAAC,CAACpB,IAAI,QAAQ,IAAI,CAACd,KAAK,CAACmC,CAAC,CAAC,CAACrB,IAAI,EAAE,CAAC;QAC/E,IAAIuB,MAAM,GAAG,CAAC,EAAE;UACZD,MAAM,CAACP,IAAI,CAAC,IAAI,CAAC7B,KAAK,CAACkC,CAAC,EAAE,CAAC,CAAC;UAC5BE,MAAM,CAACP,IAAI,CAAC,IAAI,CAAC7B,KAAK,CAACmC,CAAC,EAAE,CAAC,CAAC;QAChC,CAAC,MAAM;UACHC,MAAM,CAACP,IAAI,CAAC,IAAI,CAAC7B,KAAK,CAACmC,CAAC,EAAE,CAAC,CAAC;UAC5BC,MAAM,CAACP,IAAI,CAAC,IAAI,CAAC7B,KAAK,CAACkC,CAAC,EAAE,CAAC,CAAC;QAChC;MACJ;IACJ;;IAEA;IACA,OAAOA,CAAC,IAAIJ,GAAG,EAAE;MACbP,OAAO,CAACC,GAAG,CAAC,+BAA+B,IAAI,CAACxB,KAAK,CAACkC,CAAC,CAAC,CAACpB,IAAI,EAAE,CAAC;MAChEsB,MAAM,CAACP,IAAI,CAAC,IAAI,CAAC7B,KAAK,CAACkC,CAAC,EAAE,CAAC,CAAC;IAChC;IACA,OAAOC,CAAC,IAAIP,KAAK,EAAE;MACfL,OAAO,CAACC,GAAG,CAAC,gCAAgC,IAAI,CAACxB,KAAK,CAACmC,CAAC,CAAC,CAACrB,IAAI,EAAE,CAAC;MACjEsB,MAAM,CAACP,IAAI,CAAC,IAAI,CAAC7B,KAAK,CAACmC,CAAC,EAAE,CAAC,CAAC;IAChC;;IAEA;IACA,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,MAAM,CAAC7B,MAAM,EAAE+B,CAAC,EAAE,EAAE;MACpC,IAAI,CAACtC,KAAK,CAAC2B,IAAI,GAAGW,CAAC,CAAC,GAAGF,MAAM,CAACE,CAAC,CAAC;MAChC,IAAI,CAACnC,eAAe,CAACwB,IAAI,GAAGW,CAAC,CAAC,GAAGF,MAAM,CAACE,CAAC,CAAC;IAC9C;;IAEA;IACA,IAAIX,IAAI,KAAK,CAAC,IAAIC,KAAK,KAAK,IAAI,CAAC5B,KAAK,CAACO,MAAM,GAAG,CAAC,EAAE;MAC/C,IAAI,CAACH,KAAK,GAAG,CAAC,GAAGgC,MAAM,CAAC;IAC5B;IAEAb,OAAO,CAACC,GAAG,CAAC,kBAAkBY,MAAM,CAACG,GAAG,CAACC,IAAI,IAAIA,IAAI,CAAC1B,IAAI,CAAC,CAAC2B,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;EAC7E;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}