{"ast":null,"code":"/**\n * @module PreferenceSorter\n * @description A class that implements a merge sort algorithm with custom comparisons\n * for sorting cat names based on user preferences.\n */export class PreferenceSorter{constructor(items){this.items=items;this.preferences=new Map();this.currentRankings=[...items];this.ranks=[];this.rec=new Array(items.length).fill(0);}// When comparing items, we'll use the name property for the map key\naddPreference(item1,item2,value){const key=\"\".concat(item1.name,\"-\").concat(item2.name);this.preferences.set(key,value);}getPreference(item1,item2){const key=\"\".concat(item1.name,\"-\").concat(item2.name);const reverseKey=\"\".concat(item2.name,\"-\").concat(item1.name);if(this.preferences.has(key)){return this.preferences.get(key);}if(this.preferences.has(reverseKey)){return-this.preferences.get(reverseKey);}return 0;}getCurrentRankings(){if(this.ranks.length>0){return this.ranks;}return this.currentRankings;}async sort(compareCallback){console.log('Starting sort process with items:',this.items);const n=this.items.length;if(!this.rec||this.rec.length!==n){this.rec=new Array(n).fill(0);}await this.sortRecursive(0,n-1,compareCallback);console.log('Sort completed. Final ranks:',this.ranks);return this.ranks;}async sortRecursive(left,right,compareCallback){if(right-left<1){if(left===right){this.ranks.push(this.items[left]);console.log(\"Added single item to ranks: \".concat(this.items[left].name));}return;}const mid=Math.floor((left+right)/2);console.log(\"Splitting array at indices \".concat(left,\"-\").concat(mid,\" and \").concat(mid+1,\"-\").concat(right));await this.sortRecursive(left,mid,compareCallback);await this.sortRecursive(mid+1,right,compareCallback);await this.mergeSubGroups(left,mid,right,compareCallback);}async mergeSubGroups(left,mid,right,compareCallback){console.log(\"Merging subarrays: \".concat(left,\"-\").concat(mid,\" with \").concat(mid+1,\"-\").concat(right));let i=left;let j=mid+1;const merged=[];while(i<=mid&&j<=right){console.log(\"Comparing \".concat(this.items[i].name,\" with \").concat(this.items[j].name));const result=await compareCallback(this.items[i],this.items[j]);console.log(\"Comparison result: \".concat(result));if(result<=-0.5){// First name preferred\nconsole.log(\"\".concat(this.items[i].name,\" preferred over \").concat(this.items[j].name));merged.push(this.items[i++]);}else if(result>=0.5){// Second name preferred\nconsole.log(\"\".concat(this.items[j].name,\" preferred over \").concat(this.items[i].name));merged.push(this.items[j++]);}else{// Handle near-ties with slight preference\nconsole.log(\"Near tie between \".concat(this.items[i].name,\" and \").concat(this.items[j].name));if(result<0){merged.push(this.items[i++]);merged.push(this.items[j++]);}else{merged.push(this.items[j++]);merged.push(this.items[i++]);}}}// Add remaining elements\nwhile(i<=mid){console.log(\"Adding remaining left item: \".concat(this.items[i].name));merged.push(this.items[i++]);}while(j<=right){console.log(\"Adding remaining right item: \".concat(this.items[j].name));merged.push(this.items[j++]);}// Update original array\nfor(let k=0;k<merged.length;k++){this.items[left+k]=merged[k];this.currentRankings[left+k]=merged[k];}// Only update ranks at the final merge\nif(left===0&&right===this.items.length-1){this.ranks=[...merged];}console.log(\"Merged result: \".concat(merged.map(item=>item.name).join(', ')));}}","map":{"version":3,"names":["PreferenceSorter","constructor","items","preferences","Map","currentRankings","ranks","rec","Array","length","fill","addPreference","item1","item2","value","key","concat","name","set","getPreference","reverseKey","has","get","getCurrentRankings","sort","compareCallback","console","log","n","sortRecursive","left","right","push","mid","Math","floor","mergeSubGroups","i","j","merged","result","k","map","item","join"],"sources":["/Users/aaron/Desktop/Side Projects/name-picker/meow-namester-react/src/utils/sortingAlgorithm.js"],"sourcesContent":["/**\n * @module PreferenceSorter\n * @description A class that implements a merge sort algorithm with custom comparisons\n * for sorting cat names based on user preferences.\n */\n\nexport class PreferenceSorter {\n    constructor(items) {\n        this.items = items;\n        this.preferences = new Map();\n        this.currentRankings = [...items];\n        this.ranks = [];\n        this.rec = new Array(items.length).fill(0);\n    }\n\n    // When comparing items, we'll use the name property for the map key\n    addPreference(item1, item2, value) {\n        const key = `${item1.name}-${item2.name}`;\n        this.preferences.set(key, value);\n    }\n\n    getPreference(item1, item2) {\n        const key = `${item1.name}-${item2.name}`;\n        const reverseKey = `${item2.name}-${item1.name}`;\n        \n        if (this.preferences.has(key)) {\n            return this.preferences.get(key);\n        }\n        if (this.preferences.has(reverseKey)) {\n            return -this.preferences.get(reverseKey);\n        }\n        return 0;\n    }\n\n    getCurrentRankings() {\n        if (this.ranks.length > 0) {\n            return this.ranks;\n        }\n        return this.currentRankings;\n    }\n\n    async sort(compareCallback) {\n        console.log('Starting sort process with items:', this.items);\n        const n = this.items.length;\n        \n        if (!this.rec || this.rec.length !== n) {\n            this.rec = new Array(n).fill(0);\n        }\n        \n        await this.sortRecursive(0, n - 1, compareCallback);\n        console.log('Sort completed. Final ranks:', this.ranks);\n        return this.ranks;\n    }\n\n    async sortRecursive(left, right, compareCallback) {\n        if (right - left < 1) {\n            if (left === right) {\n                this.ranks.push(this.items[left]);\n                console.log(`Added single item to ranks: ${this.items[left].name}`);\n            }\n            return;\n        }\n\n        const mid = Math.floor((left + right) / 2);\n        console.log(`Splitting array at indices ${left}-${mid} and ${mid + 1}-${right}`);\n        await this.sortRecursive(left, mid, compareCallback);\n        await this.sortRecursive(mid + 1, right, compareCallback);\n        await this.mergeSubGroups(left, mid, right, compareCallback);\n    }\n\n    async mergeSubGroups(left, mid, right, compareCallback) {\n        console.log(`Merging subarrays: ${left}-${mid} with ${mid + 1}-${right}`);\n        let i = left;\n        let j = mid + 1;\n        const merged = [];\n\n        while (i <= mid && j <= right) {\n            console.log(`Comparing ${this.items[i].name} with ${this.items[j].name}`);\n            const result = await compareCallback(this.items[i], this.items[j]);\n            console.log(`Comparison result: ${result}`);\n\n            if (result <= -0.5) {  // First name preferred\n                console.log(`${this.items[i].name} preferred over ${this.items[j].name}`);\n                merged.push(this.items[i++]);\n            } else if (result >= 0.5) {  // Second name preferred\n                console.log(`${this.items[j].name} preferred over ${this.items[i].name}`);\n                merged.push(this.items[j++]);\n            } else {\n                // Handle near-ties with slight preference\n                console.log(`Near tie between ${this.items[i].name} and ${this.items[j].name}`);\n                if (result < 0) {\n                    merged.push(this.items[i++]);\n                    merged.push(this.items[j++]);\n                } else {\n                    merged.push(this.items[j++]);\n                    merged.push(this.items[i++]);\n                }\n            }\n        }\n\n        // Add remaining elements\n        while (i <= mid) {\n            console.log(`Adding remaining left item: ${this.items[i].name}`);\n            merged.push(this.items[i++]);\n        }\n        while (j <= right) {\n            console.log(`Adding remaining right item: ${this.items[j].name}`);\n            merged.push(this.items[j++]);\n        }\n\n        // Update original array\n        for (let k = 0; k < merged.length; k++) {\n            this.items[left + k] = merged[k];\n            this.currentRankings[left + k] = merged[k];\n        }\n\n        // Only update ranks at the final merge\n        if (left === 0 && right === this.items.length - 1) {\n            this.ranks = [...merged];\n        }\n\n        console.log(`Merged result: ${merged.map(item => item.name).join(', ')}`);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}