{"ast":null,"code":"/**\n * @module useSupabaseStorage\n * @description A custom React hook that provides persistent storage using Supabase.\n * Manages real-time synchronization of data between the client and Supabase backend.\n */import{useState,useEffect}from'react';import{supabase}from'./supabaseClient';function useSupabaseStorage(tableName){let initialValue=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];let userName=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'';const[storedValue,setStoredValue]=useState(initialValue);const[loading,setLoading]=useState(true);const[error,setError]=useState(null);useEffect(()=>{if(!userName)return;fetchData();// Set up real-time subscription\nconst subscription=supabase.channel(\"\".concat(tableName,\"_changes\")).on('postgres_changes',{event:'*',schema:'public',table:tableName,filter:userName?\"user_name=eq.\".concat(userName):undefined},()=>{fetchData();}).subscribe();return()=>{subscription.unsubscribe();};},[tableName,userName]);async function fetchData(){try{setLoading(true);const{data,error:fetchError}=await supabase.from('cat_name_ratings').select(\"\\n          rating,\\n          wins,\\n          losses,\\n          name_id,\\n          name_options (\\n            id,\\n            name\\n          )\\n        \").eq('user_name',userName);if(fetchError)throw fetchError;setStoredValue((data===null||data===void 0?void 0:data.map(item=>({id:item.name_id,name:item.name_options.name,rating:item.rating,wins:item.wins,losses:item.losses})))||initialValue);}catch(err){console.error('Error fetching data:',err);setError(err);}finally{setLoading(false);}}async function setValue(newValue){if(!userName)return;try{// First, ensure all names exist in name_options\nconst names=Array.isArray(newValue)?newValue.map(v=>v.name):[newValue.name];const{data:nameOptions,error:nameError}=await supabase.from('name_options').select('id, name').in('name',names);if(nameError)throw nameError;// Create a map of name to name_id\nconst nameToIdMap=nameOptions.reduce((acc,_ref)=>{let{id,name}=_ref;acc[name]=id;return acc;},{});// Prepare records for upsert\nconst records=(Array.isArray(newValue)?newValue:[newValue]).map(item=>({user_name:userName,name_id:nameToIdMap[item.name],rating:Math.round(item.rating||1500),wins:item.wins||0,losses:item.losses||0,updated_at:new Date().toISOString()})).filter(record=>record.name_id);if(records.length===0){throw new Error('No valid records to update');}const{error:upsertError}=await supabase.from('cat_name_ratings').upsert(records,{onConflict:'user_name,name_id',returning:'minimal'});if(upsertError)throw upsertError;// Fetch updated data\nawait fetchData();}catch(err){console.error('Error updating data:',err);setError(err);throw err;}}async function clearUserData(){if(!userName)return;try{const{error:deleteError}=await supabase.from('cat_name_ratings').delete().eq('user_name',userName);if(deleteError)throw deleteError;setStoredValue(initialValue);}catch(err){console.error('Error clearing user data:',err);setError(err);throw err;}}return[storedValue,setValue,{loading,error,clearUserData}];}export default useSupabaseStorage;","map":{"version":3,"names":["useState","useEffect","supabase","useSupabaseStorage","tableName","initialValue","arguments","length","undefined","userName","storedValue","setStoredValue","loading","setLoading","error","setError","fetchData","subscription","channel","concat","on","event","schema","table","filter","subscribe","unsubscribe","data","fetchError","from","select","eq","map","item","id","name_id","name","name_options","rating","wins","losses","err","console","setValue","newValue","names","Array","isArray","v","nameOptions","nameError","in","nameToIdMap","reduce","acc","_ref","records","user_name","Math","round","updated_at","Date","toISOString","record","Error","upsertError","upsert","onConflict","returning","clearUserData","deleteError","delete"],"sources":["/Users/aaron/Desktop/Side Projects/name-picker/meow-namester-react/src/supabase/useSupabaseStorage.js"],"sourcesContent":["/**\n * @module useSupabaseStorage\n * @description A custom React hook that provides persistent storage using Supabase.\n * Manages real-time synchronization of data between the client and Supabase backend.\n */\n\nimport { useState, useEffect } from 'react';\nimport { supabase } from './supabaseClient';\n\nfunction useSupabaseStorage(tableName, initialValue = [], userName = '') {\n  const [storedValue, setStoredValue] = useState(initialValue);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    if (!userName) return;\n    fetchData();\n    \n    // Set up real-time subscription\n    const subscription = supabase\n      .channel(`${tableName}_changes`)\n      .on('postgres_changes', \n        { \n          event: '*', \n          schema: 'public', \n          table: tableName,\n          filter: userName ? `user_name=eq.${userName}` : undefined\n        }, \n        () => {\n          fetchData();\n        }\n      )\n      .subscribe();\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [tableName, userName]);\n\n  async function fetchData() {\n    try {\n      setLoading(true);\n      const { data, error: fetchError } = await supabase\n        .from('cat_name_ratings')\n        .select(`\n          rating,\n          wins,\n          losses,\n          name_id,\n          name_options (\n            id,\n            name\n          )\n        `)\n        .eq('user_name', userName);\n\n      if (fetchError) throw fetchError;\n\n      setStoredValue(data?.map(item => ({\n        id: item.name_id,\n        name: item.name_options.name,\n        rating: item.rating,\n        wins: item.wins,\n        losses: item.losses\n      })) || initialValue);\n    } catch (err) {\n      console.error('Error fetching data:', err);\n      setError(err);\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  async function setValue(newValue) {\n    if (!userName) return;\n    \n    try {\n      // First, ensure all names exist in name_options\n      const names = Array.isArray(newValue) \n        ? newValue.map(v => v.name)\n        : [newValue.name];\n\n      const { data: nameOptions, error: nameError } = await supabase\n        .from('name_options')\n        .select('id, name')\n        .in('name', names);\n\n      if (nameError) throw nameError;\n\n      // Create a map of name to name_id\n      const nameToIdMap = nameOptions.reduce((acc, { id, name }) => {\n        acc[name] = id;\n        return acc;\n      }, {});\n\n      // Prepare records for upsert\n      const records = (Array.isArray(newValue) ? newValue : [newValue])\n        .map(item => ({\n          user_name: userName,\n          name_id: nameToIdMap[item.name],\n          rating: Math.round(item.rating || 1500),\n          wins: item.wins || 0,\n          losses: item.losses || 0,\n          updated_at: new Date().toISOString()\n        }))\n        .filter(record => record.name_id);\n\n      if (records.length === 0) {\n        throw new Error('No valid records to update');\n      }\n\n      const { error: upsertError } = await supabase\n        .from('cat_name_ratings')\n        .upsert(records, {\n          onConflict: 'user_name,name_id',\n          returning: 'minimal'\n        });\n\n      if (upsertError) throw upsertError;\n\n      // Fetch updated data\n      await fetchData();\n    } catch (err) {\n      console.error('Error updating data:', err);\n      setError(err);\n      throw err;\n    }\n  }\n\n  async function clearUserData() {\n    if (!userName) return;\n\n    try {\n      const { error: deleteError } = await supabase\n        .from('cat_name_ratings')\n        .delete()\n        .eq('user_name', userName);\n\n      if (deleteError) throw deleteError;\n\n      setStoredValue(initialValue);\n    } catch (err) {\n      console.error('Error clearing user data:', err);\n      setError(err);\n      throw err;\n    }\n  }\n\n  return [storedValue, setValue, { loading, error, clearUserData }];\n}\n\nexport default useSupabaseStorage; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}