{"ast":null,"code":"var _s = $RefreshSig$();\n/**\n * @module useSupabaseStorage\n * @description A custom React hook that provides persistent storage using Supabase.\n * Manages real-time synchronization of data between the client and Supabase backend.\n * Handles CRUD operations for cat names, ratings, and user data.\n * \n * @example\n * // Basic usage in a component\n * const [ratings, setRatings, { loading, error }] = useSupabaseStorage('cat_names', [], 'JohnDoe');\n * \n * // Update ratings\n * await setRatings([\n *   { name: 'Whiskers', elo_rating: 1500, wins: 2, losses: 1 },\n *   { name: 'Mittens', elo_rating: 1600, wins: 3, losses: 0 }\n * ]);\n * \n * // Clear user data\n * const { clearUserData } = useSupabaseStorage('cat_names', [], 'JohnDoe')[2];\n * await clearUserData();\n * \n * @param {string} tableName - Name of the Supabase table to interact with\n * @param {Array} initialValue - Initial value to use before data is loaded\n * @param {string} userName - Username to filter data by\n * @returns {[Array, Function, Object]} Tuple containing:\n *   - Current stored value\n *   - Function to update the value\n *   - Object with loading state, error state, and utility functions\n */\n\nimport { useState, useEffect } from 'react';\nimport { supabase } from './supabaseClient';\nfunction useSupabaseStorage(tableName, initialValue = [], userName = '') {\n  _s();\n  const [storedValue, setStoredValue] = useState(initialValue);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  useEffect(() => {\n    if (!userName) return;\n    fetchData();\n\n    // Set up real-time subscription\n    const subscription = supabase.channel(`${tableName}_changes`).on('postgres_changes', {\n      event: '*',\n      schema: 'public',\n      table: tableName,\n      filter: `user_name=eq.${userName}`\n    }, payload => {\n      console.log('Change received!', payload);\n      fetchData();\n    }).subscribe();\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [tableName, userName]);\n\n  /**\n   * Fetches the latest data from Supabase\n   * @private\n   */\n  async function fetchData() {\n    try {\n      setLoading(true);\n      const {\n        data,\n        error: fetchError\n      } = await supabase.from('cat_name_ratings').select(`\n          rating,\n          wins,\n          losses,\n          created_at,\n          name_options (\n            name\n          )\n        `).eq('user_name', userName).order('rating', {\n        ascending: false\n      });\n      if (fetchError) throw fetchError;\n      setStoredValue((data === null || data === void 0 ? void 0 : data.map(item => ({\n        name: item.name_options.name,\n        rating: item.rating,\n        wins: item.wins,\n        losses: item.losses\n      }))) || initialValue);\n    } catch (err) {\n      console.error('Error fetching data:', err);\n      setError(err);\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  /**\n   * Updates data in Supabase\n   * @param {Array|Object} newValue - New data to store\n   * @throws {Error} If there's an error updating the data\n   */\n  async function setValue(newValue) {\n    if (!userName) return;\n    try {\n      // First, get the name_ids from name_options\n      const {\n        data: nameOptions,\n        error: nameError\n      } = await supabase.from('name_options').select('id, name').in('name', Array.isArray(newValue) ? newValue.map(v => v.name) : [newValue.name]);\n      if (nameError) throw nameError;\n\n      // Create a map of name to name_id\n      const nameToIdMap = nameOptions.reduce((acc, {\n        id,\n        name\n      }) => {\n        acc[name] = id;\n        return acc;\n      }, {});\n\n      // Prepare the records for upsert\n      const records = (Array.isArray(newValue) ? newValue : [newValue]).map(item => ({\n        user_name: userName,\n        name_id: nameToIdMap[item.name],\n        rating: item.rating || 1500,\n        wins: item.wins || 0,\n        losses: item.losses || 0,\n        updated_at: new Date().toISOString()\n      })).filter(record => record.name_id); // Only include records with valid name_ids\n\n      if (records.length === 0) {\n        throw new Error('No valid records to update');\n      }\n      const {\n        error: upsertError\n      } = await supabase.from('cat_name_ratings').upsert(records, {\n        onConflict: 'user_name,name_id',\n        returning: 'minimal'\n      });\n      if (upsertError) throw upsertError;\n\n      // Fetch the updated data\n      await fetchData();\n    } catch (err) {\n      console.error('Error updating data:', err);\n      setError(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Clears all data for the current user from the specified table\n   * @throws {Error} If there's an error clearing the data\n   */\n  async function clearUserData() {\n    if (!userName) return;\n    try {\n      const {\n        error: deleteError\n      } = await supabase.from('cat_name_ratings').delete().eq('user_name', userName);\n      if (deleteError) throw deleteError;\n      setStoredValue(initialValue);\n    } catch (err) {\n      console.error('Error clearing user data:', err);\n      setError(err);\n      throw err;\n    }\n  }\n  return [storedValue, setValue, {\n    loading,\n    error,\n    clearUserData\n  }];\n}\n_s(useSupabaseStorage, \"7I0FNrSbcRydL4YWfLrml+7znFU=\");\nexport default useSupabaseStorage;","map":{"version":3,"names":["useState","useEffect","supabase","useSupabaseStorage","tableName","initialValue","userName","_s","storedValue","setStoredValue","loading","setLoading","error","setError","fetchData","subscription","channel","on","event","schema","table","filter","payload","console","log","subscribe","unsubscribe","data","fetchError","from","select","eq","order","ascending","map","item","name","name_options","rating","wins","losses","err","setValue","newValue","nameOptions","nameError","in","Array","isArray","v","nameToIdMap","reduce","acc","id","records","user_name","name_id","updated_at","Date","toISOString","record","length","Error","upsertError","upsert","onConflict","returning","clearUserData","deleteError","delete"],"sources":["/Users/aaron/Desktop/Side Projects/name-picker/meow-namester-react/src/supabase/useSupabaseStorage.js"],"sourcesContent":["/**\n * @module useSupabaseStorage\n * @description A custom React hook that provides persistent storage using Supabase.\n * Manages real-time synchronization of data between the client and Supabase backend.\n * Handles CRUD operations for cat names, ratings, and user data.\n * \n * @example\n * // Basic usage in a component\n * const [ratings, setRatings, { loading, error }] = useSupabaseStorage('cat_names', [], 'JohnDoe');\n * \n * // Update ratings\n * await setRatings([\n *   { name: 'Whiskers', elo_rating: 1500, wins: 2, losses: 1 },\n *   { name: 'Mittens', elo_rating: 1600, wins: 3, losses: 0 }\n * ]);\n * \n * // Clear user data\n * const { clearUserData } = useSupabaseStorage('cat_names', [], 'JohnDoe')[2];\n * await clearUserData();\n * \n * @param {string} tableName - Name of the Supabase table to interact with\n * @param {Array} initialValue - Initial value to use before data is loaded\n * @param {string} userName - Username to filter data by\n * @returns {[Array, Function, Object]} Tuple containing:\n *   - Current stored value\n *   - Function to update the value\n *   - Object with loading state, error state, and utility functions\n */\n\nimport { useState, useEffect } from 'react';\nimport { supabase } from './supabaseClient';\n\nfunction useSupabaseStorage(tableName, initialValue = [], userName = '') {\n  const [storedValue, setStoredValue] = useState(initialValue);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    if (!userName) return;\n    fetchData();\n    \n    // Set up real-time subscription\n    const subscription = supabase\n      .channel(`${tableName}_changes`)\n      .on('postgres_changes', \n        { \n          event: '*', \n          schema: 'public', \n          table: tableName,\n          filter: `user_name=eq.${userName}`\n        }, \n        (payload) => {\n          console.log('Change received!', payload);\n          fetchData();\n        }\n      )\n      .subscribe();\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [tableName, userName]);\n\n  /**\n   * Fetches the latest data from Supabase\n   * @private\n   */\n  async function fetchData() {\n    try {\n      setLoading(true);\n      const { data, error: fetchError } = await supabase\n        .from('cat_name_ratings')\n        .select(`\n          rating,\n          wins,\n          losses,\n          created_at,\n          name_options (\n            name\n          )\n        `)\n        .eq('user_name', userName)\n        .order('rating', { ascending: false });\n\n      if (fetchError) throw fetchError;\n\n      setStoredValue(data?.map(item => ({\n        name: item.name_options.name,\n        rating: item.rating,\n        wins: item.wins,\n        losses: item.losses\n      })) || initialValue);\n    } catch (err) {\n      console.error('Error fetching data:', err);\n      setError(err);\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  /**\n   * Updates data in Supabase\n   * @param {Array|Object} newValue - New data to store\n   * @throws {Error} If there's an error updating the data\n   */\n  async function setValue(newValue) {\n    if (!userName) return;\n    \n    try {\n      // First, get the name_ids from name_options\n      const { data: nameOptions, error: nameError } = await supabase\n        .from('name_options')\n        .select('id, name')\n        .in('name', Array.isArray(newValue) \n          ? newValue.map(v => v.name)\n          : [newValue.name]\n        );\n\n      if (nameError) throw nameError;\n\n      // Create a map of name to name_id\n      const nameToIdMap = nameOptions.reduce((acc, { id, name }) => {\n        acc[name] = id;\n        return acc;\n      }, {});\n\n      // Prepare the records for upsert\n      const records = (Array.isArray(newValue) ? newValue : [newValue])\n        .map(item => ({\n          user_name: userName,\n          name_id: nameToIdMap[item.name],\n          rating: item.rating || 1500,\n          wins: item.wins || 0,\n          losses: item.losses || 0,\n          updated_at: new Date().toISOString()\n        }))\n        .filter(record => record.name_id); // Only include records with valid name_ids\n\n      if (records.length === 0) {\n        throw new Error('No valid records to update');\n      }\n\n      const { error: upsertError } = await supabase\n        .from('cat_name_ratings')\n        .upsert(records, {\n          onConflict: 'user_name,name_id',\n          returning: 'minimal'\n        });\n\n      if (upsertError) throw upsertError;\n\n      // Fetch the updated data\n      await fetchData();\n    } catch (err) {\n      console.error('Error updating data:', err);\n      setError(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Clears all data for the current user from the specified table\n   * @throws {Error} If there's an error clearing the data\n   */\n  async function clearUserData() {\n    if (!userName) return;\n\n    try {\n      const { error: deleteError } = await supabase\n        .from('cat_name_ratings')\n        .delete()\n        .eq('user_name', userName);\n\n      if (deleteError) throw deleteError;\n\n      setStoredValue(initialValue);\n    } catch (err) {\n      console.error('Error clearing user data:', err);\n      setError(err);\n      throw err;\n    }\n  }\n\n  return [storedValue, setValue, { loading, error, clearUserData }];\n}\n\nexport default useSupabaseStorage; "],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAC3C,SAASC,QAAQ,QAAQ,kBAAkB;AAE3C,SAASC,kBAAkBA,CAACC,SAAS,EAAEC,YAAY,GAAG,EAAE,EAAEC,QAAQ,GAAG,EAAE,EAAE;EAAAC,EAAA;EACvE,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGT,QAAQ,CAACK,YAAY,CAAC;EAC5D,MAAM,CAACK,OAAO,EAAEC,UAAU,CAAC,GAAGX,QAAQ,CAAC,IAAI,CAAC;EAC5C,MAAM,CAACY,KAAK,EAAEC,QAAQ,CAAC,GAAGb,QAAQ,CAAC,IAAI,CAAC;EAExCC,SAAS,CAAC,MAAM;IACd,IAAI,CAACK,QAAQ,EAAE;IACfQ,SAAS,CAAC,CAAC;;IAEX;IACA,MAAMC,YAAY,GAAGb,QAAQ,CAC1Bc,OAAO,CAAC,GAAGZ,SAAS,UAAU,CAAC,CAC/Ba,EAAE,CAAC,kBAAkB,EACpB;MACEC,KAAK,EAAE,GAAG;MACVC,MAAM,EAAE,QAAQ;MAChBC,KAAK,EAAEhB,SAAS;MAChBiB,MAAM,EAAE,gBAAgBf,QAAQ;IAClC,CAAC,EACAgB,OAAO,IAAK;MACXC,OAAO,CAACC,GAAG,CAAC,kBAAkB,EAAEF,OAAO,CAAC;MACxCR,SAAS,CAAC,CAAC;IACb,CACF,CAAC,CACAW,SAAS,CAAC,CAAC;IAEd,OAAO,MAAM;MACXV,YAAY,CAACW,WAAW,CAAC,CAAC;IAC5B,CAAC;EACH,CAAC,EAAE,CAACtB,SAAS,EAAEE,QAAQ,CAAC,CAAC;;EAEzB;AACF;AACA;AACA;EACE,eAAeQ,SAASA,CAAA,EAAG;IACzB,IAAI;MACFH,UAAU,CAAC,IAAI,CAAC;MAChB,MAAM;QAAEgB,IAAI;QAAEf,KAAK,EAAEgB;MAAW,CAAC,GAAG,MAAM1B,QAAQ,CAC/C2B,IAAI,CAAC,kBAAkB,CAAC,CACxBC,MAAM,CAAC;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,CAAC,CACDC,EAAE,CAAC,WAAW,EAAEzB,QAAQ,CAAC,CACzB0B,KAAK,CAAC,QAAQ,EAAE;QAAEC,SAAS,EAAE;MAAM,CAAC,CAAC;MAExC,IAAIL,UAAU,EAAE,MAAMA,UAAU;MAEhCnB,cAAc,CAAC,CAAAkB,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEO,GAAG,CAACC,IAAI,KAAK;QAChCC,IAAI,EAAED,IAAI,CAACE,YAAY,CAACD,IAAI;QAC5BE,MAAM,EAAEH,IAAI,CAACG,MAAM;QACnBC,IAAI,EAAEJ,IAAI,CAACI,IAAI;QACfC,MAAM,EAAEL,IAAI,CAACK;MACf,CAAC,CAAC,CAAC,KAAInC,YAAY,CAAC;IACtB,CAAC,CAAC,OAAOoC,GAAG,EAAE;MACZlB,OAAO,CAACX,KAAK,CAAC,sBAAsB,EAAE6B,GAAG,CAAC;MAC1C5B,QAAQ,CAAC4B,GAAG,CAAC;IACf,CAAC,SAAS;MACR9B,UAAU,CAAC,KAAK,CAAC;IACnB;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE,eAAe+B,QAAQA,CAACC,QAAQ,EAAE;IAChC,IAAI,CAACrC,QAAQ,EAAE;IAEf,IAAI;MACF;MACA,MAAM;QAAEqB,IAAI,EAAEiB,WAAW;QAAEhC,KAAK,EAAEiC;MAAU,CAAC,GAAG,MAAM3C,QAAQ,CAC3D2B,IAAI,CAAC,cAAc,CAAC,CACpBC,MAAM,CAAC,UAAU,CAAC,CAClBgB,EAAE,CAAC,MAAM,EAAEC,KAAK,CAACC,OAAO,CAACL,QAAQ,CAAC,GAC/BA,QAAQ,CAACT,GAAG,CAACe,CAAC,IAAIA,CAAC,CAACb,IAAI,CAAC,GACzB,CAACO,QAAQ,CAACP,IAAI,CAClB,CAAC;MAEH,IAAIS,SAAS,EAAE,MAAMA,SAAS;;MAE9B;MACA,MAAMK,WAAW,GAAGN,WAAW,CAACO,MAAM,CAAC,CAACC,GAAG,EAAE;QAAEC,EAAE;QAAEjB;MAAK,CAAC,KAAK;QAC5DgB,GAAG,CAAChB,IAAI,CAAC,GAAGiB,EAAE;QACd,OAAOD,GAAG;MACZ,CAAC,EAAE,CAAC,CAAC,CAAC;;MAEN;MACA,MAAME,OAAO,GAAG,CAACP,KAAK,CAACC,OAAO,CAACL,QAAQ,CAAC,GAAGA,QAAQ,GAAG,CAACA,QAAQ,CAAC,EAC7DT,GAAG,CAACC,IAAI,KAAK;QACZoB,SAAS,EAAEjD,QAAQ;QACnBkD,OAAO,EAAEN,WAAW,CAACf,IAAI,CAACC,IAAI,CAAC;QAC/BE,MAAM,EAAEH,IAAI,CAACG,MAAM,IAAI,IAAI;QAC3BC,IAAI,EAAEJ,IAAI,CAACI,IAAI,IAAI,CAAC;QACpBC,MAAM,EAAEL,IAAI,CAACK,MAAM,IAAI,CAAC;QACxBiB,UAAU,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MACrC,CAAC,CAAC,CAAC,CACFtC,MAAM,CAACuC,MAAM,IAAIA,MAAM,CAACJ,OAAO,CAAC,CAAC,CAAC;;MAErC,IAAIF,OAAO,CAACO,MAAM,KAAK,CAAC,EAAE;QACxB,MAAM,IAAIC,KAAK,CAAC,4BAA4B,CAAC;MAC/C;MAEA,MAAM;QAAElD,KAAK,EAAEmD;MAAY,CAAC,GAAG,MAAM7D,QAAQ,CAC1C2B,IAAI,CAAC,kBAAkB,CAAC,CACxBmC,MAAM,CAACV,OAAO,EAAE;QACfW,UAAU,EAAE,mBAAmB;QAC/BC,SAAS,EAAE;MACb,CAAC,CAAC;MAEJ,IAAIH,WAAW,EAAE,MAAMA,WAAW;;MAElC;MACA,MAAMjD,SAAS,CAAC,CAAC;IACnB,CAAC,CAAC,OAAO2B,GAAG,EAAE;MACZlB,OAAO,CAACX,KAAK,CAAC,sBAAsB,EAAE6B,GAAG,CAAC;MAC1C5B,QAAQ,CAAC4B,GAAG,CAAC;MACb,MAAMA,GAAG;IACX;EACF;;EAEA;AACF;AACA;AACA;EACE,eAAe0B,aAAaA,CAAA,EAAG;IAC7B,IAAI,CAAC7D,QAAQ,EAAE;IAEf,IAAI;MACF,MAAM;QAAEM,KAAK,EAAEwD;MAAY,CAAC,GAAG,MAAMlE,QAAQ,CAC1C2B,IAAI,CAAC,kBAAkB,CAAC,CACxBwC,MAAM,CAAC,CAAC,CACRtC,EAAE,CAAC,WAAW,EAAEzB,QAAQ,CAAC;MAE5B,IAAI8D,WAAW,EAAE,MAAMA,WAAW;MAElC3D,cAAc,CAACJ,YAAY,CAAC;IAC9B,CAAC,CAAC,OAAOoC,GAAG,EAAE;MACZlB,OAAO,CAACX,KAAK,CAAC,2BAA2B,EAAE6B,GAAG,CAAC;MAC/C5B,QAAQ,CAAC4B,GAAG,CAAC;MACb,MAAMA,GAAG;IACX;EACF;EAEA,OAAO,CAACjC,WAAW,EAAEkC,QAAQ,EAAE;IAAEhC,OAAO;IAAEE,KAAK;IAAEuD;EAAc,CAAC,CAAC;AACnE;AAAC5D,EAAA,CAxJQJ,kBAAkB;AA0J3B,eAAeA,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}