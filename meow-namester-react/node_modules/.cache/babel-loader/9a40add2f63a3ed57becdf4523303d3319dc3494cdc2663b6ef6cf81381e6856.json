{"ast":null,"code":"/**\n * @module PreferenceSorter\n * @description A class that implements a merge sort algorithm specifically designed\n * for sorting cat names based on preference counts from user selections.\n */\n\nexport class PreferenceSorter {\n  constructor(items) {\n    // Ensure items are in the correct format with cat_name and preference_count\n    this.namMember = items.map(item => {\n      return typeof item === 'object' ? item : {\n        cat_name: item,\n        preference_count: 0\n      };\n    });\n    this.nrec = 0;\n    this.rec = new Array(items.length);\n    this.ranks = [];\n    console.log('PreferenceSorter initialized with items:', this.namMember);\n  }\n  getCurrentRankings() {\n    // If we have completed rankings, return those\n    if (this.ranks.length > 0) {\n      return this.ranks;\n    }\n    // Otherwise, return the current state of namMember\n    return [...this.namMember];\n  }\n  async sort(compareCallback) {\n    console.log('Starting sort process with items:', this.namMember);\n    const n = this.namMember.length;\n    for (let i = 0; i < n; i++) {\n      this.rec[i] = 0;\n    }\n    let mid = Math.floor(n / 2);\n    await this.sortRecursive(0, n - 1, compareCallback);\n    console.log('Sort completed. Final ranks:', this.ranks);\n    return this.ranks;\n  }\n  async sortRecursive(left, right, compareCallback) {\n    if (right - left < 1) {\n      if (left === right) {\n        this.ranks.push(this.namMember[left]);\n        console.log(`Added single item to ranks: ${JSON.stringify(this.namMember[left])}`);\n      }\n      return;\n    }\n    const mid = Math.floor((left + right) / 2);\n    console.log(`Splitting array at indices ${left}-${mid} and ${mid + 1}-${right}`);\n    await this.sortRecursive(left, mid, compareCallback);\n    await this.sortRecursive(mid + 1, right, compareCallback);\n    await this.mergeSubGroups(left, mid, right, compareCallback);\n  }\n  async mergeSubGroups(left, mid, right, compareCallback) {\n    console.log(`Merging subarrays: ${left}-${mid} with ${mid + 1}-${right}`);\n    let i = left;\n    let j = mid + 1;\n    const merged = [];\n    while (i <= mid && j <= right) {\n      const item1 = this.namMember[i];\n      const item2 = this.namMember[j];\n      console.log(`Comparing ${item1.cat_name} (count: ${item1.preference_count}) with ${item2.cat_name} (count: ${item2.preference_count})`);\n\n      // Default comparison based on preference_count if no callback provided\n      const result = compareCallback ? await compareCallback(item1, item2) : Math.sign(item2.preference_count - item1.preference_count);\n      console.log(`Comparison result: ${result}`);\n      if (result <= -0.5) {\n        console.log(`${item1.cat_name} preferred over ${item2.cat_name}`);\n        merged.push(this.namMember[i++]);\n      } else if (result >= 0.5) {\n        console.log(`${item2.cat_name} preferred over ${item1.cat_name}`);\n        merged.push(this.namMember[j++]);\n      } else {\n        // Handle near-ties with slight preference to higher preference_count\n        console.log(`Near tie between ${item1.cat_name} and ${item2.cat_name}`);\n        if (item1.preference_count >= item2.preference_count) {\n          merged.push(this.namMember[i++]);\n          merged.push(this.namMember[j++]);\n        } else {\n          merged.push(this.namMember[j++]);\n          merged.push(this.namMember[i++]);\n        }\n      }\n    }\n\n    // Add remaining elements\n    while (i <= mid) {\n      console.log(`Adding remaining left item: ${this.namMember[i].cat_name}`);\n      merged.push(this.namMember[i++]);\n    }\n    while (j <= right) {\n      console.log(`Adding remaining right item: ${this.namMember[j].cat_name}`);\n      merged.push(this.namMember[j++]);\n    }\n\n    // Update original array\n    for (let k = 0; k < merged.length; k++) {\n      this.namMember[left + k] = merged[k];\n    }\n\n    // Only update ranks at the final merge\n    if (left === 0 && right === this.namMember.length - 1) {\n      this.ranks = [...merged];\n    }\n    console.log(`Merged result: ${merged.map(item => `${item.cat_name}(${item.preference_count})`).join(', ')}`);\n  }\n}","map":{"version":3,"names":["PreferenceSorter","constructor","items","namMember","map","item","cat_name","preference_count","nrec","rec","Array","length","ranks","console","log","getCurrentRankings","sort","compareCallback","n","i","mid","Math","floor","sortRecursive","left","right","push","JSON","stringify","mergeSubGroups","j","merged","item1","item2","result","sign","k","join"],"sources":["/Users/aaron/Desktop/Side Projects/name-picker/meow-namester-react/src/utils/sortingAlgorithm.js"],"sourcesContent":["/**\n * @module PreferenceSorter\n * @description A class that implements a merge sort algorithm specifically designed\n * for sorting cat names based on preference counts from user selections.\n */\n\nexport class PreferenceSorter {\n    constructor(items) {\n        // Ensure items are in the correct format with cat_name and preference_count\n        this.namMember = items.map(item => {\n            return typeof item === 'object' ? item : { cat_name: item, preference_count: 0 };\n        });\n        this.nrec = 0;\n        this.rec = new Array(items.length);\n        this.ranks = [];\n        console.log('PreferenceSorter initialized with items:', this.namMember);\n    }\n\n    getCurrentRankings() {\n        // If we have completed rankings, return those\n        if (this.ranks.length > 0) {\n            return this.ranks;\n        }\n        // Otherwise, return the current state of namMember\n        return [...this.namMember];\n    }\n\n    async sort(compareCallback) {\n        console.log('Starting sort process with items:', this.namMember);\n        const n = this.namMember.length;\n        for (let i = 0; i < n; i++) {\n            this.rec[i] = 0;\n        }\n        let mid = Math.floor(n / 2);\n        await this.sortRecursive(0, n - 1, compareCallback);\n        console.log('Sort completed. Final ranks:', this.ranks);\n        return this.ranks;\n    }\n\n    async sortRecursive(left, right, compareCallback) {\n        if (right - left < 1) {\n            if (left === right) {\n                this.ranks.push(this.namMember[left]);\n                console.log(`Added single item to ranks: ${JSON.stringify(this.namMember[left])}`);\n            }\n            return;\n        }\n\n        const mid = Math.floor((left + right) / 2);\n        console.log(`Splitting array at indices ${left}-${mid} and ${mid + 1}-${right}`);\n        await this.sortRecursive(left, mid, compareCallback);\n        await this.sortRecursive(mid + 1, right, compareCallback);\n        await this.mergeSubGroups(left, mid, right, compareCallback);\n    }\n\n    async mergeSubGroups(left, mid, right, compareCallback) {\n        console.log(`Merging subarrays: ${left}-${mid} with ${mid + 1}-${right}`);\n        let i = left;\n        let j = mid + 1;\n        const merged = [];\n\n        while (i <= mid && j <= right) {\n            const item1 = this.namMember[i];\n            const item2 = this.namMember[j];\n            console.log(`Comparing ${item1.cat_name} (count: ${item1.preference_count}) with ${item2.cat_name} (count: ${item2.preference_count})`);\n            \n            // Default comparison based on preference_count if no callback provided\n            const result = compareCallback ? \n                await compareCallback(item1, item2) : \n                Math.sign(item2.preference_count - item1.preference_count);\n            \n            console.log(`Comparison result: ${result}`);\n\n            if (result <= -0.5) {\n                console.log(`${item1.cat_name} preferred over ${item2.cat_name}`);\n                merged.push(this.namMember[i++]);\n            } else if (result >= 0.5) {\n                console.log(`${item2.cat_name} preferred over ${item1.cat_name}`);\n                merged.push(this.namMember[j++]);\n            } else {\n                // Handle near-ties with slight preference to higher preference_count\n                console.log(`Near tie between ${item1.cat_name} and ${item2.cat_name}`);\n                if (item1.preference_count >= item2.preference_count) {\n                    merged.push(this.namMember[i++]);\n                    merged.push(this.namMember[j++]);\n                } else {\n                    merged.push(this.namMember[j++]);\n                    merged.push(this.namMember[i++]);\n                }\n            }\n        }\n\n        // Add remaining elements\n        while (i <= mid) {\n            console.log(`Adding remaining left item: ${this.namMember[i].cat_name}`);\n            merged.push(this.namMember[i++]);\n        }\n        while (j <= right) {\n            console.log(`Adding remaining right item: ${this.namMember[j].cat_name}`);\n            merged.push(this.namMember[j++]);\n        }\n\n        // Update original array\n        for (let k = 0; k < merged.length; k++) {\n            this.namMember[left + k] = merged[k];\n        }\n\n        // Only update ranks at the final merge\n        if (left === 0 && right === this.namMember.length - 1) {\n            this.ranks = [...merged];\n        }\n\n        console.log(`Merged result: ${merged.map(item => `${item.cat_name}(${item.preference_count})`).join(', ')}`);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}