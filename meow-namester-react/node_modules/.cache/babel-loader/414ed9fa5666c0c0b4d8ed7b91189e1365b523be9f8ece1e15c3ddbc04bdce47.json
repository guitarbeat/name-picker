{"ast":null,"code":"var _s = $RefreshSig$();\n/**\n * @module useSupabaseStorage\n * @description A custom React hook that provides persistent storage using Supabase.\n * Manages real-time synchronization of data between the client and Supabase backend.\n */\n\nimport { useState, useEffect } from 'react';\nimport { supabase } from './supabaseClient';\nfunction useSupabaseStorage(tableName, initialValue = [], userName = '') {\n  _s();\n  const [storedValue, setStoredValue] = useState(initialValue);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  useEffect(() => {\n    if (!userName) return;\n    fetchData();\n\n    // Set up real-time subscription\n    const subscription = supabase.channel(`${tableName}_changes`).on('postgres_changes', {\n      event: '*',\n      schema: 'public',\n      table: tableName,\n      filter: userName ? `user_name=eq.${userName}` : undefined\n    }, () => {\n      fetchData();\n    }).subscribe();\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [tableName, userName]);\n  async function fetchData() {\n    try {\n      setLoading(true);\n      const {\n        data,\n        error: fetchError\n      } = await supabase.from('cat_name_ratings').select(`\n          rating,\n          wins,\n          losses,\n          name_id,\n          name_options (\n            id,\n            name\n          )\n        `).eq('user_name', userName);\n      if (fetchError) throw fetchError;\n      setStoredValue((data === null || data === void 0 ? void 0 : data.map(item => ({\n        id: item.name_id,\n        name: item.name_options.name,\n        rating: item.rating,\n        wins: item.wins,\n        losses: item.losses\n      }))) || initialValue);\n    } catch (err) {\n      console.error('Error fetching data:', err);\n      setError(err);\n    } finally {\n      setLoading(false);\n    }\n  }\n  async function setValue(newValue) {\n    if (!userName) return;\n    try {\n      // First, ensure all names exist in name_options\n      const names = Array.isArray(newValue) ? newValue.map(v => v.name) : [newValue.name];\n      const {\n        data: nameOptions,\n        error: nameError\n      } = await supabase.from('name_options').select('id, name').in('name', names);\n      if (nameError) throw nameError;\n\n      // Create a map of name to name_id\n      const nameToIdMap = nameOptions.reduce((acc, {\n        id,\n        name\n      }) => {\n        acc[name] = id;\n        return acc;\n      }, {});\n\n      // Prepare records for upsert\n      const records = (Array.isArray(newValue) ? newValue : [newValue]).map(item => ({\n        user_name: userName,\n        name_id: nameToIdMap[item.name],\n        rating: Math.round(item.rating || 1500),\n        wins: item.wins || 0,\n        losses: item.losses || 0,\n        updated_at: new Date().toISOString()\n      })).filter(record => record.name_id);\n      if (records.length === 0) {\n        throw new Error('No valid records to update');\n      }\n      const {\n        error: upsertError\n      } = await supabase.from('cat_name_ratings').upsert(records, {\n        onConflict: 'user_name,name_id',\n        returning: 'minimal'\n      });\n      if (upsertError) throw upsertError;\n\n      // Fetch updated data\n      await fetchData();\n    } catch (err) {\n      console.error('Error updating data:', err);\n      setError(err);\n      throw err;\n    }\n  }\n  async function clearUserData() {\n    if (!userName) return;\n    try {\n      const {\n        error: deleteError\n      } = await supabase.from('cat_name_ratings').delete().eq('user_name', userName);\n      if (deleteError) throw deleteError;\n      setStoredValue(initialValue);\n    } catch (err) {\n      console.error('Error clearing user data:', err);\n      setError(err);\n      throw err;\n    }\n  }\n  return [storedValue, setValue, {\n    loading,\n    error,\n    clearUserData\n  }];\n}\n_s(useSupabaseStorage, \"7I0FNrSbcRydL4YWfLrml+7znFU=\");\nexport default useSupabaseStorage;","map":{"version":3,"names":["useState","useEffect","supabase","useSupabaseStorage","tableName","initialValue","userName","_s","storedValue","setStoredValue","loading","setLoading","error","setError","fetchData","subscription","channel","on","event","schema","table","filter","undefined","subscribe","unsubscribe","data","fetchError","from","select","eq","map","item","id","name_id","name","name_options","rating","wins","losses","err","console","setValue","newValue","names","Array","isArray","v","nameOptions","nameError","in","nameToIdMap","reduce","acc","records","user_name","Math","round","updated_at","Date","toISOString","record","length","Error","upsertError","upsert","onConflict","returning","clearUserData","deleteError","delete"],"sources":["/Users/aaron/Desktop/Side Projects/name-picker/meow-namester-react/src/supabase/useSupabaseStorage.js"],"sourcesContent":["/**\n * @module useSupabaseStorage\n * @description A custom React hook that provides persistent storage using Supabase.\n * Manages real-time synchronization of data between the client and Supabase backend.\n */\n\nimport { useState, useEffect } from 'react';\nimport { supabase } from './supabaseClient';\n\nfunction useSupabaseStorage(tableName, initialValue = [], userName = '') {\n  const [storedValue, setStoredValue] = useState(initialValue);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    if (!userName) return;\n    fetchData();\n    \n    // Set up real-time subscription\n    const subscription = supabase\n      .channel(`${tableName}_changes`)\n      .on('postgres_changes', \n        { \n          event: '*', \n          schema: 'public', \n          table: tableName,\n          filter: userName ? `user_name=eq.${userName}` : undefined\n        }, \n        () => {\n          fetchData();\n        }\n      )\n      .subscribe();\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [tableName, userName]);\n\n  async function fetchData() {\n    try {\n      setLoading(true);\n      const { data, error: fetchError } = await supabase\n        .from('cat_name_ratings')\n        .select(`\n          rating,\n          wins,\n          losses,\n          name_id,\n          name_options (\n            id,\n            name\n          )\n        `)\n        .eq('user_name', userName);\n\n      if (fetchError) throw fetchError;\n\n      setStoredValue(data?.map(item => ({\n        id: item.name_id,\n        name: item.name_options.name,\n        rating: item.rating,\n        wins: item.wins,\n        losses: item.losses\n      })) || initialValue);\n    } catch (err) {\n      console.error('Error fetching data:', err);\n      setError(err);\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  async function setValue(newValue) {\n    if (!userName) return;\n    \n    try {\n      // First, ensure all names exist in name_options\n      const names = Array.isArray(newValue) \n        ? newValue.map(v => v.name)\n        : [newValue.name];\n\n      const { data: nameOptions, error: nameError } = await supabase\n        .from('name_options')\n        .select('id, name')\n        .in('name', names);\n\n      if (nameError) throw nameError;\n\n      // Create a map of name to name_id\n      const nameToIdMap = nameOptions.reduce((acc, { id, name }) => {\n        acc[name] = id;\n        return acc;\n      }, {});\n\n      // Prepare records for upsert\n      const records = (Array.isArray(newValue) ? newValue : [newValue])\n        .map(item => ({\n          user_name: userName,\n          name_id: nameToIdMap[item.name],\n          rating: Math.round(item.rating || 1500),\n          wins: item.wins || 0,\n          losses: item.losses || 0,\n          updated_at: new Date().toISOString()\n        }))\n        .filter(record => record.name_id);\n\n      if (records.length === 0) {\n        throw new Error('No valid records to update');\n      }\n\n      const { error: upsertError } = await supabase\n        .from('cat_name_ratings')\n        .upsert(records, {\n          onConflict: 'user_name,name_id',\n          returning: 'minimal'\n        });\n\n      if (upsertError) throw upsertError;\n\n      // Fetch updated data\n      await fetchData();\n    } catch (err) {\n      console.error('Error updating data:', err);\n      setError(err);\n      throw err;\n    }\n  }\n\n  async function clearUserData() {\n    if (!userName) return;\n\n    try {\n      const { error: deleteError } = await supabase\n        .from('cat_name_ratings')\n        .delete()\n        .eq('user_name', userName);\n\n      if (deleteError) throw deleteError;\n\n      setStoredValue(initialValue);\n    } catch (err) {\n      console.error('Error clearing user data:', err);\n      setError(err);\n      throw err;\n    }\n  }\n\n  return [storedValue, setValue, { loading, error, clearUserData }];\n}\n\nexport default useSupabaseStorage; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}